<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `tracing` crate."><meta name="keywords" content="rust, rustlang, rust-lang, tracing"><title>tracing - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../tracing/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate tracing</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all tracing's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'tracing', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/tracing/lib.rs.html#1-431' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>tracing</a></span></h1><div class='docblock'><p>A scoped, structured logging and diagnostics system.</p>
<h1 id="overview" class="section-header"><a href="#overview">Overview</a></h1>
<p><code>tracing</code> is a framework for instrumenting Rust programs to collect
structured, event-based diagnostic information.</p>
<p>In asynchronous systems like Tokio, interpreting traditional log messages can
often be quite challenging. Since individual tasks are multiplexed on the same
thread, associated events and log lines are intermixed making it difficult to
trace the logic flow. <code>tracing</code> expands upon logging-style diagnostics by
allowing libraries and applications to record structured events with additional
information about <em>temporality</em> and <em>causality</em> — unlike a log message, a span
in <code>tracing</code> has a beginning and end time, may be entered and exited by the
flow of execution, and may exist within a nested tree of similar spans. In
addition, <code>tracing</code> spans are <em>structured</em>, with the ability to record typed
data as well as textual messages.</p>
<p>The <code>tracing</code> crate provides the APIs necessary for instrumenting libraries
and applications to emit trace data.</p>
<h1 id="core-concepts" class="section-header"><a href="#core-concepts">Core Concepts</a></h1>
<p>The core of <code>tracing</code>'s API is composed of <em>spans</em>, <em>events</em> and
<em>subscribers</em>. We'll cover these in turn.</p>
<h2 id="spans" class="section-header"><a href="#spans">Spans</a></h2>
<p>A <a href="span/index.html"><code>span</code></a> represents a <em>period of time</em> during which a program was executing
in some context. A thread of execution is said to <em>enter</em> a span when it
begins executing in that context, and to <em>exit</em> the span when switching to
another context. The span in which a thread is currently executing is
referred to as the <em>current</em> span.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tracing</span>::{<span class="ident">span</span>, <span class="ident">Level</span>};
<span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="macro">span</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">TRACE</span>, <span class="string">&quot;my_span&quot;</span>);
<span class="comment">// `enter` returns a RAII guard which, when dropped, exits the span. this</span>
<span class="comment">// indicates that we are in the span for the current lexical scope.</span>
<span class="kw">let</span> <span class="ident">_enter</span> <span class="op">=</span> <span class="ident">span</span>.<span class="ident">enter</span>();
<span class="comment">// perform some work in the context of `my_span`...</span></pre></div>
<p>The <a href="span/index.html"><code>span</code> module</a>'s documentation provides further details on how to use spans.</p>
<h2 id="events" class="section-header"><a href="#events">Events</a></h2>
<p>An <a href="struct.Event.html"><code>Event</code></a> represents a <em>point</em> in time. It signifies something that
happened while the trace was executing. <code>Event</code>s are comparable to the log
records emitted by unstructured logging code, but unlike a typical log line,
an <code>Event</code> may occur within the context of a <code>Span</code>. Like a <code>Span</code>, it
may have fields, and implicitly inherits any of the fields present on its
parent span.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tracing</span>::{<span class="ident">event</span>, <span class="ident">span</span>, <span class="ident">Level</span>};

<span class="comment">// records an event outside of any span context:</span>
<span class="macro">event</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">INFO</span>, <span class="string">&quot;something happened&quot;</span>);

<span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="macro">span</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">INFO</span>, <span class="string">&quot;my_span&quot;</span>);
<span class="kw">let</span> <span class="ident">_guard</span> <span class="op">=</span> <span class="ident">span</span>.<span class="ident">enter</span>();

<span class="comment">// records an event within &quot;my_span&quot;.</span>
<span class="macro">event</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">DEBUG</span>, <span class="string">&quot;something happened inside my_span&quot;</span>);</pre></div>
<p>Essentially, <code>Event</code>s  bridge the gap between traditional unstructured
logging and span-based tracing. Similar to log records, they
may be recorded at a number of levels, and can have unstructured,
human-readable messages; however, they also carry key-value data and exist
within the context of the tree of spans that comprise a trace. Thus,
individual log record-like events can be pinpointed not only in time, but
in the logical execution flow of the system.</p>
<p>In general, events should be used to represent points in time <em>within</em> a
span — a request returned with a given status code, <em>n</em> new items were
taken from a queue, and so on.</p>
<h2 id="subscribers" class="section-header"><a href="#subscribers"><code>Subscriber</code>s</a></h2>
<p>As <code>Span</code>s and <code>Event</code>s occur, they are recorded or aggregated by
implementations of the <a href="subscriber/trait.Subscriber.html"><code>Subscriber</code></a> trait. <code>Subscriber</code>s are notified
when an <code>Event</code> takes place and when a <code>Span</code> is entered or exited. These
notifications are represented by the following <code>Subscriber</code> trait methods:
+ <a href="subscriber/trait.Subscriber.html#tymethod.observe_event"><code>observe_event</code></a>, called when an <code>Event</code> takes place,
+ <a href="subscriber/trait.Subscriber.html#tymethod.enter"><code>enter</code></a>, called when execution enters a <code>Span</code>,
+ <a href="subscriber/trait.Subscriber.html#tymethod.exit"><code>exit</code></a>, called when execution exits a <code>Span</code></p>
<p>In addition, subscribers may implement the <a href="subscriber/trait.Subscriber.html#tymethod.enabled"><code>enabled</code></a> function to <em>filter</em>
the notifications they receive based on <a href="struct.Metadata.html">metadata</a> describing each <code>Span</code>
or <code>Event</code>. If a call to <code>Subscriber::enabled</code> returns <code>false</code> for a given
set of metadata, that <code>Subscriber</code> will <em>not</em> be notified about the
corresponding <code>Span</code> or <code>Event</code>. For performance reasons, if no currently
active subscribers express  interest in a given set of metadata by returning
<code>true</code>, then the corresponding <code>Span</code> or <code>Event</code> will never be constructed.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>First, add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
tracing = &quot;0.1&quot;
</code></pre>
<p><code>Span</code>s are constructed using the <code>span!</code> macro, and then <em>entered</em>
to indicate that some code takes place within the context of that <code>Span</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tracing</span>::{<span class="ident">span</span>, <span class="ident">Level</span>};
<span class="comment">// Construct a new span named &quot;my span&quot; with trace log level.</span>
<span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="macro">span</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">TRACE</span>, <span class="string">&quot;my span&quot;</span>);

<span class="comment">// Enter the span, returning a guard object.</span>
<span class="kw">let</span> <span class="ident">_enter</span> <span class="op">=</span> <span class="ident">span</span>.<span class="ident">enter</span>();

<span class="comment">// Any trace events that occur before the guard is dropped will occur</span>
<span class="comment">// within the span.</span>

<span class="comment">// Dropping the guard will exit the span.</span></pre></div>
<p><code>Event</code>s are created using the <code>event!</code> macro, and are recorded when the
event is dropped:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tracing</span>::{<span class="ident">event</span>, <span class="ident">Level</span>};
<span class="macro">event</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">INFO</span>, <span class="string">&quot;something has happened!&quot;</span>);</pre></div>
<p>Users of the <a href="https://docs.rs/log/0.4.6/log/"><code>log</code></a> crate should note that <code>tracing</code> exposes a set of
macros for creating <code>Event</code>s (<code>trace!</code>, <code>debug!</code>, <code>info!</code>, <code>warn!</code>, and
<code>error!</code>) which may be invoked with the same syntax as the similarly-named
macros from the <code>log</code> crate. Often, the process of converting a project to
use <code>tracing</code> can begin with a simple drop-in replacement.</p>
<p>Let's consider the <code>log</code> crate's yak-shaving example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tracing</span>::{<span class="ident">info</span>, <span class="ident">span</span>, <span class="ident">warn</span>, <span class="ident">Level</span>};

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">shave_the_yak</span>(<span class="ident">yak</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Yak</span>) {
    <span class="kw">let</span> <span class="ident">span</span> <span class="op">=</span> <span class="macro">span</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">TRACE</span>, <span class="string">&quot;shave_the_yak&quot;</span>, <span class="question-mark">?</span><span class="ident">yak</span>);
    <span class="kw">let</span> <span class="ident">_enter</span> <span class="op">=</span> <span class="ident">span</span>.<span class="ident">enter</span>();

    <span class="comment">// Since the span is annotated with the yak, it is part of the context</span>
    <span class="comment">// for everything happening inside the span. Therefore, we don&#39;t need</span>
    <span class="comment">// to add it to the message for this event, as the `log` crate does.</span>
    <span class="macro">info</span><span class="macro">!</span>(<span class="ident">target</span>: <span class="string">&quot;yak_events&quot;</span>, <span class="string">&quot;Commencing yak shaving&quot;</span>);
    <span class="kw">loop</span> {
        <span class="kw">match</span> <span class="ident">find_a_razor</span>() {
            <span class="prelude-val">Ok</span>(<span class="ident">razor</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// We can add the razor as a field rather than formatting it</span>
                <span class="comment">// as part of the message, allowing subscribers to consume it</span>
                <span class="comment">// in a more structured manner:</span>
                <span class="macro">info</span><span class="macro">!</span>(<span class="op">%</span><span class="ident">razor</span>, <span class="string">&quot;Razor located&quot;</span>);
                <span class="ident">yak</span>.<span class="ident">shave</span>(<span class="ident">razor</span>);
                <span class="kw">break</span>;
            }
            <span class="prelude-val">Err</span>(<span class="ident">err</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// However, we can also create events with formatted messages,</span>
                <span class="comment">// just as we would for log records.</span>
                <span class="macro">warn</span><span class="macro">!</span>(<span class="string">&quot;Unable to locate a razor: {}, retrying&quot;</span>, <span class="ident">err</span>);
            }
        }
    }
}</pre></div>
<p>The <a href="https://docs.rs/tracing-attributes/latest/tracing_attributes/attr.instrument.html"><code>#[instrument]</code></a> attribute provides an easy way to
add <code>tracing</code> spans to functions. A function annotated with <code>#[instrument]</code>
will create and enter a span with that function's name every time the
function is called, with arguments to that function will be recorded as
fields using <code>fmt::Debug</code>.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tracing</span>::{<span class="ident">info</span>, <span class="ident">instrument</span>};

<span class="attribute">#[<span class="ident">instrument</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">my_function</span>(<span class="ident">my_arg</span>: <span class="ident">usize</span>) {
    <span class="comment">// This event will be recorded inside a span named `my_function` with the</span>
    <span class="comment">// field `my_arg`.</span>
    <span class="macro">info</span><span class="macro">!</span>(<span class="string">&quot;inside my_function!&quot;</span>);
    <span class="comment">// ...</span>
}</pre></div>
<p><strong>Note</strong>: using <code>#[instrument]</code> on <code>async fn</code>s requires the
<a href="https://github.com/tokio-rs/tracing/tree/master/tracing-futures"><code>tracing-futures</code></a> crate as a dependency, as well.</p>
<p>You can find more examples showing how to use this crate in the examples
directory.</p>
<h2 id="in-libraries" class="section-header"><a href="#in-libraries">In libraries</a></h2>
<p>Libraries should link only to the <code>tracing</code> crate, and use the provided
macros to record whatever information will be useful to downstream
consumers.</p>
<h2 id="in-executables" class="section-header"><a href="#in-executables">In executables</a></h2>
<p>In order to record trace events, executables have to use a <code>Subscriber</code>
implementation compatible with <code>tracing</code>. A <code>Subscriber</code> implements a
way of collecting trace data, such as by logging it to standard output.</p>
<p>The simplest way to use a subscriber is to call the <a href="subscriber/fn.set_global_default.html"><code>set_global_default</code></a>
function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">tracing</span>;

<span class="kw">let</span> <span class="ident">my_subscriber</span> <span class="op">=</span> <span class="ident">FooSubscriber</span>::<span class="ident">new</span>();
<span class="ident">tracing</span>::<span class="ident">subscriber</span>::<span class="ident">set_global_default</span>(<span class="ident">my_subscriber</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;setting tracing default failed&quot;</span>);</pre></div>
<p><strong>Note:</strong> Libraries should <em>NOT</em> call <code>set_global_default()</code>! That will
cause conflicts when executables try to set the default later.</p>
<p>This subscriber will be used as the default in all threads for the
remainder of the duration of the program, similar to setting the logger
in the <code>log</code> crate.</p>
<p>In addition, the default subscriber can be set through using the
<a href="subscriber/fn.with_default.html"><code>with_default</code></a> function. This follows the <code>tokio</code> pattern of using
closures to represent executing code in a context that is exited at the end
of the closure. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="kw">let</span> <span class="ident">my_subscriber</span> <span class="op">=</span> <span class="ident">FooSubscriber</span>::<span class="ident">new</span>();
<span class="ident">tracing</span>::<span class="ident">subscriber</span>::<span class="ident">with_default</span>(<span class="ident">my_subscriber</span>, <span class="op">|</span><span class="op">|</span> {
    <span class="comment">// Any trace events generated in this closure or by functions it calls</span>
    <span class="comment">// will be collected by `my_subscriber`.</span>
})</pre></div>
<p>This approach allows trace data to be collected by multiple subscribers
within different contexts in the program. Note that the override only applies to the
currently executing thread; other threads will not see the change from with_default.</p>
<p>Any trace events generated outside the context of a subscriber will not be collected.</p>
<p>Once a subscriber has been set, instrumentation points may be added to the
executable using the <code>tracing</code> crate's macros.</p>
<p>In addition to <code>tracing</code> and <code>tracing-core</code>, the <a href="https://github.com/tokio-rs/tracing"><code>tokio-rs/tracing</code></a> repository
contains several additional crates designed to be used with the <code>tracing</code> ecosystem.
This includes a collection of <code>Subscriber</code> implementations, as well as utility
and adapter crates to assist in writing <code>Subscriber</code>s and instrumenting
applications.</p>
<p>In particular, the following crates are likely to be of interest:</p>
<ul>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-futures"><code>tracing-futures</code></a> provides a compatibility layer with the <code>futures</code>
crate, allowing spans to be attached to <code>Future</code>s, <code>Stream</code>s, and <code>Executor</code>s.</li>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-fmt"><code>tracing-fmt</code></a> provides a <code>Subscriber</code> implementation for
logging formatted trace data to stdout, with similar filtering and
formatting to the <code>env-logger</code> crate.</li>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-log"><code>tracing-log</code></a> provides a compatibility layer with the <code>log</code> crate,
allowing log messages to be recorded as <code>tracing</code> <code>Event</code>s within the
trace tree. This is useful when a project using <code>tracing</code> have
dependencies which use <code>log</code>.</li>
<li><a href="https://crates.io/crates/tracing-timing"><code>tracing-timing</code></a> implements inter-event timing metrics on top of <code>tracing</code>.
It provides a subscriber that records the time elapsed between pairs of
<code>tracing</code> events and generates histograms.</li>
</ul>
<p><strong>Note:</strong> that some of the ecosystem crates are currently unreleased and
undergoing active development. They may be less stable than <code>tracing</code> and
<code>tracing-core</code>.</p>
<h2 id="crate-feature-flags" class="section-header"><a href="#crate-feature-flags">Crate Feature Flags</a></h2>
<p>The following crate feature flags are available:</p>
<ul>
<li>
<p>A set of features controlling the <a href="level_filters/index.html#compile-time-filters">static verbosity level</a>.</p>
</li>
<li>
<p><code>log</code>: causes trace instrumentation points to emit <a href="https://docs.rs/log/0.4.6/log/"><code>log</code></a> records as well
as trace events. This is intended for use in libraries whose users may be
using either <code>tracing</code> or <code>log</code>.
<strong>Note:</strong> <code>log</code> support will not work when <code>tracing</code> is renamed in <code>Cargo.toml</code>,
due to oddities in macro expansion.</p>
</li>
<li>
<p><code>std</code>: Depend on the Rust standard library (enabled by default).</p>
<p><code>no_std</code> users may disable this feature with <code>default-features = false</code>:</p>
<pre><code class="language-toml">[dependencies]
tracing = { version = &quot;0.1.5&quot;, default-features = false }
</code></pre>
<p><strong>Note</strong>:<code>tracing</code>'s <code>no_std</code> support requires <code>liballoc</code>.</p>
</li>
</ul>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="dispatcher/index.html" title='tracing::dispatcher mod'>dispatcher</a></td><td class='docblock-short'><p>Dispatches trace events to <a href="struct.Subscriber.html"><code>Subscriber</code></a>s.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="event/index.html" title='tracing::event mod'>event</a></td><td class='docblock-short'><p>Events represent single points in time during the execution of a program.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="field/index.html" title='tracing::field mod'>field</a></td><td class='docblock-short'><p>Structured data associated with <code>Span</code>s and <code>Event</code>s.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="level_filters/index.html" title='tracing::level_filters mod'>level_filters</a></td><td class='docblock-short'><p>Trace verbosity level filtering.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="span/index.html" title='tracing::span mod'>span</a></td><td class='docblock-short'><p>Spans represent periods of time in which a program was executing in a
particular context.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="subscriber/index.html" title='tracing::subscriber mod'>subscriber</a></td><td class='docblock-short'><p>Collects and records trace data.</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.debug.html" title='tracing::debug macro'>debug</a></td><td class='docblock-short'><p>Constructs an event at the debug level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.debug_span.html" title='tracing::debug_span macro'>debug_span</a></td><td class='docblock-short'><p>Constructs a span at the debug level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.error.html" title='tracing::error macro'>error</a></td><td class='docblock-short'><p>Constructs an event at the error level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.error_span.html" title='tracing::error_span macro'>error_span</a></td><td class='docblock-short'><p>Constructs a span at the error level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.event.html" title='tracing::event macro'>event</a></td><td class='docblock-short'><p>Constructs a new <code>Event</code>.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.info.html" title='tracing::info macro'>info</a></td><td class='docblock-short'><p>Constructs an event at the info level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.info_span.html" title='tracing::info_span macro'>info_span</a></td><td class='docblock-short'><p>Constructs a span at the info level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.span.html" title='tracing::span macro'>span</a></td><td class='docblock-short'><p>Constructs a new span.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.trace.html" title='tracing::trace macro'>trace</a></td><td class='docblock-short'><p>Constructs an event at the trace level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.trace_span.html" title='tracing::trace_span macro'>trace_span</a></td><td class='docblock-short'><p>Constructs a span at the trace level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.warn.html" title='tracing::warn macro'>warn</a></td><td class='docblock-short'><p>Constructs an event at the warn level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.warn_span.html" title='tracing::warn_span macro'>warn_span</a></td><td class='docblock-short'><p>Constructs a span at the warn level.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Dispatch.html" title='tracing::Dispatch struct'>Dispatch</a></td><td class='docblock-short'><p><code>Dispatch</code> trace data to a <a href="trait.Subscriber.html"><code>Subscriber</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Event.html" title='tracing::Event struct'>Event</a></td><td class='docblock-short'><p><code>Event</code>s represent single points in time where something occurred during the
execution of a program.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Level.html" title='tracing::Level struct'>Level</a></td><td class='docblock-short'><p>Describes the level of verbosity of a span or event.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Metadata.html" title='tracing::Metadata struct'>Metadata</a></td><td class='docblock-short'><p>Metadata describing a <a href="../span/index.html">span</a> or <a href="../event/index.html">event</a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Span.html" title='tracing::Span struct'>Span</a></td><td class='docblock-short'><p>A handle representing a span, with the capability to enter the span if it
exists.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Subscriber.html" title='tracing::Subscriber trait'>Subscriber</a></td><td class='docblock-short'><p>Trait representing the functions required to collect trace data.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Value.html" title='tracing::Value trait'>Value</a></td><td class='docblock-short'><p>A field value of an erased type.</p>
</td></tr></table><h2 id='attributes' class='section-header'><a href="#attributes">Attribute Macros</a></h2>
<table><tr class='module-item'><td><a class="attr" href="attr.instrument.html" title='tracing::instrument attr'>instrument</a></td><td class='docblock-short'><p>Instruments a function to create and enter a <code>tracing</code> <a href="https://docs.rs/tracing/0.1.5/tracing/span/index.html">span</a> every time
the function is called.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "tracing";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>